You will learn how to:
	•Describe features of the Bash shell
	•Explain how to display shell variables
	•Explain how environment variables are used
	•Describe the value of the alias command
	
	
What is a shell? 	
	•A shell accepts and interprets commands.
	•A shell is an environment in which commands, programs, and shell scripts are run.
	•There are many types of Linux shells available. Bash is one of them.
	
The primary purpose of a shell is to allow the user to interact with the computer operating system. 
It has two different functions. 
	One is a program and the other is a command interpreter. 
As a program shell, it provides the interface for utilities and programs. 
As a command interpreter, a shell accepts and interprets the commands you enter into the commandline interface (CLI) or 	terminal.

What is the Bourne Again Shell (Bash)? 
•Bash is the default shell in Linux.
•It offers an efficient environment for interacting with the operating system and scripting
		
Bash is a programming language for running commands. Bash is the default shell in Linux operating systems. 
It is widely used, so some familiarity with Bash is expected in many systems or development roles

what Bash shell variables are, how to name them,what the rules are for writing them, and how to assign a value to them.
	In a shell, a variable is used to store values.
	A variable value can be a string, a number, or special characters; by default, variables are strings.
	
	name=value
	
In a shell, a variable is used to store values. 
Variables can be a name, a number, or special characters; by default, variables are strings. 
Variables are character strings to which you can assign a value; a value can be assigned as a number, text, file name, device, or other data type. 
Variables are a symbolic label for a portion of memory used to assign values and read and manipulate contents.
Scripts or other commands can call shell variables. 
The values that these shell variables represent are then substituted into the script or command	

By convention and as a good practice, the name of a variable that a user has created is in lowercase. 
Environment (system) variable names are capitalized. Also, there is no space before or after the equal sign

There are rules for defining or creating variables in the shell.
When defining a variable, the variable name must be prefixed with the dollar ($) symbol.
The variable must contain no spaces or special characters within the variable name. 
A variable name can contain only letters (a to z or A to Z), numbers (0 to 9), or the underscore character ( _), and they are usually capitalized (e.g. VARIABLE).


Naming variables in Bash can be difficult, but if you name variables properly, it is useful.  

Good variable names are crucial; they assist in making sense of what the variable is used for and the readability of the variable. 
It is good practice to be consistent in your naming pattern. 

restart_student=
restart_us_cohort_1=
restart_spring_student

Unhelpful, confusing, or vague variable names can contribute to the disconnect between a variable and its value.
The variable names on this slide are examples of a few good and a few bad variable names.

student=
us_cohort=
spring!=

batch_time=Afternoon

Variables are assigned by using the = operator. The value of the variable is located to the right of the = operator.  

 restart_student=Li Juan
 
Variables can be a name, a number, or special characters; by default, all variables are treated as strings, even if a variable is assigned to a number. There is no space between the variable name and the value



[ec2-user@ip-172-31-16-21 ~]$ echo $USER
ec2-user
[ec2-user@ip-172-31-16-21 ~]$ echo $HOME
/home/ec2-user
[ec2-user@ip-172-31-16-21 ~]$ echo $SHELL
/bin/bash

[ec2-user@ip-172-31-16-21 ~]$ time=2.30pm
[ec2-user@ip-172-31-16-21 ~]$ echo $time
2.30pm
[ec2-user@ip-172-31-16-21 ~]$ echo aws class start by $time
aws class start by 2.30pm


In a shell, environment variables are the same as shell variables. 
Structurally, these variables are no different from each other. Both use the key-value pair, and they are separated by the equal (=) sign.

Environment variables are system wide, and all child processes and shells in herit them. With environment variables, you can pass information about the current operating environment to a program running. 
Finally, applications and daemons reference environment variables as needed.


$HOME		Defines the user's home directory
$PATH		Indicates the location of the commands
$SHELL		Defines the login shell type
$USER		Contains the user's system name

At the command prompt, enter the echo command and an environment variable from the following list:
•echo $HOME
•echo $SHELL
•echo $USER
•echo $PATH

The envcommand is used to view environment variables

If you run the env command without any options, it will display the variables in your current environment. 
With options, you can use this command to view, set, or remove environment variables


XDG_VTNR		Specifies the virtual terminal number
XDG_SESSONS_ID		Specifies the session 
IDHOSTNAME		Specifies the name of the computer
SHELL			Specifies the shell path
TERM			Defines terminal handling

The env command is a shell command for Linux. You use this command to print a list of environment variables or run another utility in an altered environment

[ec2-user@ip-172-31-16-21 ~]$ env
SHELL=/bin/bash
HISTCONTROL=ignoredups
SYSTEMD_COLORS=false
HISTSIZE=1000
HOSTNAME=ip-172-31-16-21.us-west-2.compute.internal
PWD=/home/ec2-user
LOGNAME=ec2-user
XDG_SESSION_TYPE=tty
MOTD_SHOWN=pam
HOME=/home/ec2-user
LANG=C.UTF-8
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.m4a=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.oga=01;36:*.opus=01;36:*.spx=01;36:*.xspf=01;36:
SSH_CONNECTION=122.164.9.129 55880 172.31.16.21 22
XDG_SESSION_CLASS=user
SELINUX_ROLE_REQUESTED=
TERM=xterm-256color
LESSOPEN=||/usr/bin/lesspipe.sh %s
USER=ec2-user
SELINUX_USE_CURRENT_RANGE=
SHLVL=1
XDG_SESSION_ID=1
XDG_RUNTIME_DIR=/run/user/1000
S_COLORS=auto
SSH_CLIENT=122.164.9.129 55880 22
which_declare=declare -f
PATH=/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
SELINUX_LEVEL_REQUESTED=
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
MAIL=/var/spool/mail/ec2-user
SSH_TTY=/dev/pts/0
BASH_FUNC_which%%=() {  ( alias;
 eval ${which_declare} ) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot "$@"
}
_=/usr/bin/env
[ec2-user@ip-172-31-16-21 ~]$


[ec2-user@ip-172-31-16-21 ~]$ env GREETING="HELLO WORLD" bash -c 'echo $GREETING'
HELLO WORLD

[ec2-user@ip-172-31-16-21 ~]$ env time=2:30PM Course="AWS" job="with placement support" bash -c 'echo $Course start on $time once completed the course and $job'
AWS start on 2:30PM once completed the course and with placement support


During the initialization process of Bash environment files, two different initialization shell files are invoked.

The /etc/profile file contains system-wide environment configurations and startup scripts for login setup. 

The command line prompt is set within this file. All configurations that you want to apply to all system users’ environments should be added to this file.
When you log in, Bash reads the /etc/profile instructions. 
The /etc/profile file usually sets the shell variables PATH, USER, HOSTNAME, etc.
The /etc/bashrc file contains system-wide functions and aliases, including other configurations that apply to all system users


By using aliases,you can define new commands by substituting a long command with a short one. 
Aliases can be set temporarily in the current shell, but it is more common to set them in the user's .bashrc file so that they are permanent. 
In the example, ll is often substituted or aliased to ls –l.
Extra: In many distributions, you can create an alias of destructive commands —such as rm, cp, and mv —with the -i interactive option


[ec2-user@ip-172-31-16-21 ~]$ alias hi='history'
[ec2-user@ip-172-31-16-21 ~]$ hi
    1  clear
    2  echo $USER
    3  echo $HOME
    4  echo $SHELL
    5  time=2.30pm
    6  echo $time
    7  echo aws class start by $time
    8  env
    9  env GREETING="HELLO WORLD" bash -c 'echo$GREETING'
   10  env GREETING="HELLO WORLD" bash -c 'echo $GREETING'
   11  env -i bash
   
   [ec2-user@ip-172-31-16-21 ~]$ unalias hi
   [ec2-user@ip-172-31-16-21 ~]$ hi
-bash: hi: command not found


The .bashrc file is stored in the home directory of each user. 
As mentioned earlier,the .bashrc file is used to store configurations specific to the user. When creating an alias, remember that after you create it, the alias isa pplied to the .bashrc file. 


[ec2-user@ip-172-31-16-21 ~]$ vi .bashrc
alias ji='history'
alias jk='ls -ld '

[ec2-user@ip-172-31-16-21 ~]$ source ~/.bashrc
[ec2-user@ip-172-31-16-21 ~]$ jk /
dr-xr-xr-x. 18 root root 237 Oct 23 00:07 /
[ec2-user@ip-172-31-16-21 ~]$ jk /etc/
drwxr-xr-x. 76 root root 16384 Oct 30 09:36 /etc/
[ec2-user@ip-172-31-16-21 ~]$ ls -ld /etc/
drwxr-xr-x. 76 root root 16384 Oct 30 09:36 /etc/

Lab-

Task 2: Create an alias for a backup operation


to create a backup # tar -cvzf name.tar fodler file

[ec2-user@ip-10-0-10-46 ~]$ alias backup='tar -cvzf '
[ec2-user@ip-10-0-10-46 ~]$ backup backup_companyA.tar.gz CompanyA
CompanyA/
CompanyA/Management/
CompanyA/Management/Sections.csv
CompanyA/Management/Promotions.csv
CompanyA/Employees/
CompanyA/Employees/Schedules.csv
CompanyA/Finance/
CompanyA/Finance/Salary.csv
CompanyA/HR/
CompanyA/HR/Managers.csv
CompanyA/HR/Assessments.csv
CompanyA/IA/
CompanyA/SharedFolders/
CompanyA/bin/
CompanyA/bin/hello.sh
[ec2-user@ip-10-0-10-46 ~]$ ls
backup_companyA.tar.gz  CompanyA

Task 3: Explore and update the PATH environment variable

[ec2-user@ip-10-0-10-46 ~]$ cd /home/ec2-user/CompanyA/bin
[ec2-user@ip-10-0-10-46 bin]$ ls
hello.sh
[ec2-user@ip-10-0-10-46 bin]$ cat hello.sh
#!/bin/bash

echo "Hello $USER"
[ec2-user@ip-10-0-10-46 bin]$ ./hello.sh
Hello ec2-user



[ec2-user@ip-10-0-10-46 CompanyA]$ PATH=$PATH:/home/ec2-user/CompanyA/bin

[ec2-user@ip-10-0-10-46 CompanyA]$ echo $PATH
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/ec2-user/.local/bin:/home/ec2-user/bin:/home/ec2-user/CompanyA/bin

[ec2-user@ip-10-0-10-46 CompanyA]$ hello.sh
Hello ec2-user

--------------------------------------------------------------------------------------
Bash Shell Scripting


You will learn how to:
•Describe common tasks that are accomplished through shell scripts
•Describe basic commands that are frequently included in shell scripts
•Describe basic logical control statements that are frequently included in shell scripts
•Run a shell script

What are scripts?
	•Scripts are text files of commands and related data.
	•When the text file is processed, the commands are run.
	•Scripts can be set as scheduled tasks by using cron.
	•Automation allows scripts to run more quickly than if they are run manually.
	•Scripts are consistent due to automation removing the potential for manual errors. 
	
[ec2-user@ip-172-31-16-21 ~]$ vi 1.sh
[ec2-user@ip-172-31-16-21 ~]$ ls -l 1.sh
-rw-r--r--. 1 ec2-user ec2-user 38 Oct 30 11:19 1.sh
[ec2-user@ip-172-31-16-21 ~]$ chmod +x 1.sh
[ec2-user@ip-172-31-16-21 ~]$ ls -l 1.sh
-rwxr-xr-x. 1 ec2-user ec2-user 38 Oct 30 11:19 1.sh
[ec2-user@ip-172-31-16-21 ~]$ ./1.sh
1.sh
total 4
-rwxr-xr-x. 1 ec2-user ec2-user 38 Oct 30 11:19 1.sh
Thu Oct 30 11:20:04 UTC 2025
               Local time: Thu 2025-10-30 11:20:04 UTC
           Universal time: Thu 2025-10-30 11:20:04 UTC
                 RTC time: Thu 2025-10-30 11:20:03
                Time zone: n/a (UTC, +0000)
System clock synchronized: yes
              NTP service: active
          RTC in local TZ: no	


What are scripts?Common script tasks:
•Creating backup jobs
•Archivinglog files
•Configuring systems and services
•Simplifying repetitive task
•Automating tasks          


#!/bin/bash
# Script to backup the home directory
tar -cf backup-home.tar /home/ec2-user/etc ~/1.sh

echo “backup job complete at `date`”


The process of creating a script follows these steps:
	1.Create the script using a text editor.
	2.Set the script permissions to run.  [x]
	3.Use ./to run the script
	
	
in AWS ec2 userdata

#!/bin/bash
yum install httpd -y
service httpd start
chkconfig httpd on
echo "WC to Webserver" > /var/www/html/index.html



#!/bin/bash
sudo yum install httpd -y
sudo service httpd start
sudo chkconfig httpd on
cd /var/www/html
sudo  touch index.html
sudo chmod 775 index.html
echo "WC to Webserver" > index.html



•Bash ignores lines that are preceded with #.
•The # character is used to define comments or notes to the user that might provide instructions or options.

#!/bin/bash  => If the first line does not define the interpreter, the operating system will find one, usually the one defined for the current shell

sudo yum install httpd -y
# this file to install httpd

The second echo command runs and displays a message.


#!/bin/sh
#!/bin/bash

•#!is referred to as a shebang.
•The first line defines the interpreter to use (it gives the path and name of the interpreter).
•Scripts must begin with the directive for which shell will run them.
•The location and shell can be different.
•Each shell has its own syntax, which tells the system what syntax to expect


•Use # to define comments, including the purpose of the script, author information, special directives for the script, examples, and others


•Some administrators create a script template, which contains all the relevant information and sections.
•The template might include the following:
	Title
	Purpose
	Author’s name and contact information
	Special instructions or examples
	
Declare a Bash variable
	•Declare (create) your own variables.
	•Use these custom variables in scripts

[ec2-user@ip-172-31-16-21 ~]$ vi 3.sh
[ec2-user@ip-172-31-16-21 ~]$ chmod u+x 3.sh

	#!/bin/bash
	course="AWS"
	echo i am doing $course
	
[ec2-user@ip-172-31-16-21 ~]$ ./3.sh
i am doing AWS	

Command				Description
------------------------------------------------------------------------
echo				Displays information on the console
read				Reads a user input
subStr				Gets the substring of a string
+				Adds two numbers or combine strings
file				Opens a file
mkdir				Creates a directory
cp				Copies files
mv				Moves or renames files
chmod				Sets permissions on files
rm				Deletes files, folders,etc.
ls				Lists directories


You can use all the shell commands that you saw earlier in the course, such as grep, touch, and redirectors 
( >, >>, <, << ).
You can also use the shell script to create programs using statements such as if, else if, for, while, case, and create functions using the function keyword

1.For this demonstration, create a file and enter the following text:
#!/bin/bash
echo "What is your name?“
read name echo "Hello $name”

2.As soon as you finish, save the file and run the following command (for this example, the file is named getname.sh):chmod +x getname.sh

3.Run the script by enteringthe following (for this example, the file is named getname.sh):./getname.sh

#!/bin/bash
sum=$(($1 + $2))
echo $1 + $2 equals $sum

#!/bin/bash		-> shebang and which shell command need to run
sum=$(($1+$2))  	-> $1 $2 positional parameters, (()) is used for arithmetic expresion in bash
echo $sum		-> print the result to the screen




•Arguments are values that you want the script to act on.
•Arguments are passed to the script by including them in a script invocation command separated by spaces.
•For example, $1 is the first argument, and $2 is the second argument


A conditional statement runs a command or block of commands only if a specified condition is satisfied. 
script named delete.sh copies a file named file1 from the current directory to the /tmp directory. 
If the copy command is successful, the script deletes the original file from the current directory.

Notice how the script uses the special variable $? to test whether the copy command was successful or not. 
This variable contains a value that represents the exit status code of the last command that was run. 
If the command was successful, the return value is 0; otherwise, the return value is 1.


#!/bin/bash

# Copy file1 from the current directory to /tmp.

cp file1 /tmp

# Delete file1 from the current directory
# if the copy was successful.

if [ $? -eq 0 ]  # $?  stores the exit status of the last execute command 0 sucess 1 fail
then
   rm file1
fi

--------------------------------

#!/bin/bash
echo "Enter a Number: "
read num

if [ $num -gt 10 ]
then
   echo "The number is greater than 10"
fi   

---------------------
less than 40  fail
40 to 60 above pass third class
61 to 89 second class
90 to 100 first class


#!/bin/bash
echo "Enter your marsk: "
read mark

if [ $mark -lt 40 ]

then
    echo "Fail"
elif [ $mark -ge 40 ] && [ $mark -le 60 ]

then
    echo "Pass - Third Class"

elif [ $mark -ge 61 ] && [ $mark -le 89 ]

then
   echo "Pass - Second Class"
elif [ $mark -ge 90 ] && [ $mark -le 100 ]
then
   echo "Pass - First Class"

else
   echo "Invalid Marks entered"
fi

------------
•If the first command succeeds with an exit code of 0 (success), then the subsequent command runs.
•This is the simplest conditional statement.
•An if statement must end with the fi keyword

if <condition>
then
   <command>
fi

Or 
if writing everything in one line:

if <condition>; then <command>; fi

Note that the semicolon (;) is required to separate multiple commands on the same line.
Indentation is used for better readability but is not required

if <condition>
then
   <command>
else
   <other command>
fi

--------------

if <condition>
then
   <command>
elif 
  <other condition>
then
  <other command>
else
  <default  command>
fi


You can embed if-elif-else statements.
•You can access all local objects of its immediately enclosing function and also of any function or functions that enclose that function.
•Nesting is theoretically possible to unlimited depth

Numeric comparision:
----------------------
-eq		equal to
-ne		not equal to
-gt		greater than
-lt		less than
-ge		greater than or equal to
-le		less than or equal to 


#!/bin/bash

mun=80

if test $num -gt 40
then
    echo "pass"
else
    echo "fail"
fi    


---

nun=80

if [ $num -gt 40]
then
    echo "pass"
else
    echo "fail"
fi    






string comparisons:
----------------------
=		equal to
!=		not equal to
-z		string is empty
-n		string is not empty

#!/bin/bash

name="tim"

if test "$name" = "tim"
then
    echo "Hello Tim"
else
    echo "unknown user"
fi   

file test
--------------------------------------
-f		file exists and is a regular file
-d		directory exists
-r		file is readable
-w		file is writable
-x		file is executable
-s		file is not empty

#!/bin/bash

file="1.sh"

if test -f "$file"
then
    echo "$file exists"
else
    echo "$file not found"
fi    


•<		is less than (withindouble parentheses): (("$a" < "$b"))•
•<=		is less than or equal to (within double parentheses): (("$a" <= "$b"))
•>		is greater than (within double parentheses): (("$a" > "$b"))
•>=		is greater than or equal to (within double parentheses)

In these examples, you can see that brackets or double parentheses surround the condition.
•(( are for numerical comparison:
•(( $a < $b )) is equivalent to [ $a –lt $b ]
•You will also see some conditions using double brackets:
•if [[ $a –lt $b ]]    
•This is basically a notation equivalent to a simple bracket with enhanced features,but this goes beyond this course.
•Note also that “ are not mandatory: if [ "$a" -lt "$b" ] is equivalent to if [ $a -lt $b ]

Integer comparison operators examples

#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo "$a is equal to $b"

elif [ $a -lt $b ]
then
   echo "$a is less than to $b"

else
   echo "$a is grater than to $b"

fi   


-----------------
a=10
b=20

if (( $a == $b ))
then
   echo "$a is equal to $b"

elif (( $a > $b ))
then
   echo "$a is grater than to $b"

else
   echo "$a is less than to $b"

fi   


[] / [[ ]] for string and file condition checks
(( )) when doing arithmetic (no $ required before variables inside)

Double quotes are not mandatory: if [ "$a" -lt "$b" ] is equivalent to if [ $a -lt $b ]•
The semicolon (;) is mandatory only if the clauses of the if statement are written in the same line: 
if [ $a -lt $b ]; then ...; else ...; fi



String comparison operations 


#!/bin/bash
# Compares letters $1 and $2 

if [ “$1” = “$2” ]

then 
   echo letters are the same

elif [ $1 \< $2 ]

then
    echo the first letter is before the second letter

else
    echo the second letter is before the first letter

fi


-------------------
Sections of a script can be configured to repeat themselves.
•The loop can end:
	–After a specific number of repeats (for statement)
	–Or until a condition is met (untilstatement)
	–Or while a condition is true (whilestatement)
•Looping extends the power and complexity of scripts


Loops the command a specified number of times
•Bracketed by do and done

#!/bin/bash
# The for loop

for x in 1 2 3 4 5 a b c d
do
echo "the value is $x"
done


The for statement To loop a command a specific number of times, use the for statement.

#!/bin/bash
# The while loop

counter=3

while [ $counter -le 5 ]
do
  echo  $counter
  ((counter++))
done

-----------
#!/bin/bash
# The while loop

counter=3

while [ $counter -le 5 ]
do
  echo  $counter
  ((counter++))
  
  if [ $counter -eq $1 ]
  then
     break
  fi   
done

•Continues running the script as long as the specified condition is true
•Bracketed by whileand done

----------------
•Similar to the while statement
•Runs code until a condition becomes true
•Bracketed by until and done

#!/bin/bash
# The until loop
counter=1
until [ $counter -gt 10 ]
do
     echo  $counter
     ((counter++))
done
echo “loop exited”
echo “counter equals $counter”


----

#!/bin/bash
counter=1

until [ $counter -gt 10 ]   # loop run until condition become true
do
   echo "Couter is: $counter"  # Displays current counter
   ((counter++))               # increments counter
   
   if [ $counter -eq $1 ]      # checks if counter equals user argument
   then
      break			# exits loop early
   fi  
done   

----

#!/bin/bash
# The continue statement
counter=1

while [ $counter -le 10 ]
do
  echo $counter
  if [ $counter = $1 ]
  then
  ((counter++))
    
    echo "Skipping the rest of the loop"
  continue
  fi
((counter++))
   echo "Completed all loop commands"

done

echo "loop exited"echo "counter equals $counter"


The continue keyword terminates the current loop iteration and returns control back to the top of the loop. 
In the example, the bottom part of the loop is skipped when the counter is equal to 7. 
Specifically:•The parameter is 3.
•The if condition is met when counter = 3.
•When this condition is true, the continue statement is run, and the rest of the loop is skipped.
•The loop keeps running until counter = 11 (original while condition)

[ec2-user@ip-172-31-21-209 ~]$ ./8.sh 3
1
Completed all loop commands
2
Completed all loop commands
3
Skipping the rest of the loop
4
Completed all loop commands
5
Completed all loop commands
6
Completed all loop commands

----------------
The readcommand


Reads user input into a variable in the script

#!/bin/bash
echo "Hello. What is your name?"
read VARNAME
echo "Glad to meet you, $VARNAME"


Sets the user input as a variable

Calls the variable and uses it as output

--------

•true and false commands are used with loops to manage their conditions.
•These commands return predetermined exit status (either a status of true or a status of false).
•A Boolean expression is an expression that produces avalue or true or false when it is evaluated


#!/bin/bash
while true			# create a continual (infinite) loop, beacuse true always exit 
do
	echo "Enter a number between 1 and 10:"
	read  val		# reads the input from the user
	if [ $val -eq 7 ]	# Boolean experssion - evaluates to true if user enter 7
	then
	  echo "You guessed right!"
	  break			# Exits the loop when condition is met
	fi
	
	echo  "Wrong guess!"	# Display if the guess isnot correct
done



•true and false commands are used with loops to manage their conditions.
•These commands return predetermined exit status (either a status of trueor a status of false).
•A Boolean expression is an expression that produces a value or true or false when it is evaluated.The true and false commands In the example, a while statement with a true condition creates a continual loop that asks the user to enter a value between 1 and 10. If the user does not enter the value of 7, the loop continues; otherwise, the loop exists using a breakstatement.


--------------------

•Causes script to stop running and exit to the shell.
•Useful in testing
•Can return code status. Each code can be associated to a specific error
•For example:
exit 0: The program has completed without any error.
exit 1: The program has an error.
exit n: The program has a specific error.
•$?is a command to get the processing status of the last command that ran


#!/bin/bash
touch myfile.txt        # create a new empty file name myfile.txt
		        # $?  stores the exit status of the previous comand    	
if [ $? -eq 0 ]		# checks if the previous command succeeded (0)
then
   echo "File created"
   exit 0
else
   echo  "Error encountered when creating the file"
exit 1
fi

-----------------------------------

Command substitution

#!/bin/bash
echo “Hello $USER!”
echo "Today’s date is : `date`"
echo "you directory location: `pwd`"


•Commands can be placed in the syntax of other commands.
•Commands are surrounded by backticks (`).
•Commands can be useful in scripts


variable Substitution      	$name
Command Substitution	        $(date)
Arithmetic substitution 	#((a+b))


---------------------------

Bash searches for executables by using the $PATH variable. 
Bash assumes that any runnable command or script will be along that path.
•If the script is not along the path, then precede the executable name with ./
•For example, in your home directory, you wrote a script called myscript.sh and you want to run it:
•myscript.sh fails because Bash does not check your home directory for executables.
	•./myscript.sh succeeds.
•Be sure to update the settings to persist beyond the current session
.•Review: A user's profile is loaded from the files that are stored in the user's home directory:
•/home/username/.bashrc
•/home/username/.bash_history
•/home/username/.bash_profile

---------------------------
LAB - Write a shell script

[ec2-user@ip-10-0-10-231 ~]$ touch backup.sh

[ec2-user@ip-10-0-10-231 ~]$ ls -l backup.sh
-rw-rw-r-- 1 ec2-user ec2-user 0 Oct 31 11:27 backup.sh

[ec2-user@ip-10-0-10-231 ~]$ vi backup.sh

[ec2-user@ip-10-0-10-231 ~]$ chmod u+x backup.sh

[ec2-user@ip-10-0-10-231 ~]$ ls -R backup
backups/   backup.sh

[ec2-user@ip-10-0-10-231 ~]$ ls -R backups/
backups/:

[ec2-user@ip-10-0-10-231 ~]$ ./backup.sh
tar: Removing leading `/' from member names
/home/ec2-user/CompanyA/
/home/ec2-user/CompanyA/Management/
/home/ec2-user/CompanyA/Management/Sections.csv
/home/ec2-user/CompanyA/Management/Promotions.csv
/home/ec2-user/CompanyA/Employees/
/home/ec2-user/CompanyA/Employees/Schedules.csv
/home/ec2-user/CompanyA/Finance/
/home/ec2-user/CompanyA/Finance/Salary.csv
/home/ec2-user/CompanyA/Finance/Hourly.csv
/home/ec2-user/CompanyA/HR/
/home/ec2-user/CompanyA/HR/Managers.csv
/home/ec2-user/CompanyA/HR/Assessments.csv
/home/ec2-user/CompanyA/IA/
/home/ec2-user/CompanyA/SharedFolders/

[ec2-user@ip-10-0-10-231 ~]$ ls -R backups/
backups/:
2025_10_31_11:32:51_11_32-backup-CompanyA.tar.gz

[ec2-user@ip-10-0-10-231 ~]$ date
Fri Oct 31 11:33:10 UTC 2025
[ec2-user@ip-10-0-10-231 ~]$ ./backup.sh
tar: Removing leading `/' from member names
/home/ec2-user/CompanyA/
/home/ec2-user/CompanyA/Management/
/home/ec2-user/CompanyA/Management/Sections.csv
/home/ec2-user/CompanyA/Management/Promotions.csv
/home/ec2-user/CompanyA/Employees/
/home/ec2-user/CompanyA/Employees/Schedules.csv
/home/ec2-user/CompanyA/Finance/
/home/ec2-user/CompanyA/Finance/Salary.csv
/home/ec2-user/CompanyA/Finance/Hourly.csv
/home/ec2-user/CompanyA/HR/
/home/ec2-user/CompanyA/HR/Managers.csv
/home/ec2-user/CompanyA/HR/Assessments.csv
/home/ec2-user/CompanyA/IA/
/home/ec2-user/CompanyA/SharedFolders/

[ec2-user@ip-10-0-10-231 ~]$ ls -R backups/
backups/:
2025_10_31_11:32:51_11_32-backup-CompanyA.tar.gz
2025_10_31_11:33:15_11_33-backup-CompanyA.tar.gz
[ec2-user@ip-10-0-10-231 ~]$

